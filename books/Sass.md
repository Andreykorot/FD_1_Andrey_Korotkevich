# SCSS
### Введение
Стайлгайд – это не просто приятный документ для чтения, обрисовывающий идеальное состояние вашего кода. Это ключевой документ в жизни проекта, описывающий, как и почему код должен быть написан. Для небольших проектов это может показаться излишним, но очень помогает сохранять кодовую базу чистой, масштабируемой и лёгкой в поддержке.

Излишне говорить, что чем больше разработчиков участвуют в проекте, тем больше руководств требуется. Так же, чем больше проект, тем более важен стайлгайд.

### Ключевые принципы
Между тем, CSS является простым языком. Sass, предназначенный для написания CSS, не должен стать значительно сложнее обычного CSS. [Принцип KISS](https://ru.wikipedia.org/wiki/KISS_(принцип)) (Keep It Simple Stupid, делай это проще, тупица) является ключевым моментом и в некоторых случаях может даже взять верх над [принципом DRY](https://ru.wikipedia.org/wiki/Don’t_repeat_yourself) (Don’t Repeat Yourself, не повторяйся).

Иногда лучше немного повторяться, чтобы держать код понятным, а не строить тяжелую, громоздкую, сложную систему, которая полностью нечитаема и сложна в поддержке.

### Синтаксис и форматирование
Грубо говоря, есть основные принципы, которых стоит придерживаться:
* отступы табами;
* правильно написанные многострочные CSS правила;
* осмысленное использование пробелов и фигурных скобок

    
    // Хорошо
    .foo {
    display: block;
    overflow: hidden;
    padding: 0 1rem;
    }
    
    // Плохо
    .foo
    {
    display: block;
    overflow:hidden;
    padding:0 1rem;
    }
    
# Строки
### Кавычки
CSS не требует, чтобы строки были помещены в кавычки, даже те, что содержат пробелы. Возьмите названия семейства шрифтов, например: не имеет значения, оборачиваете ли вы их в кавычки для CSS-парсера или нет.

Из-за этого, Sass также не требует помещения строк в кавычки. Более того (и, к счастью, согласитесь), строка в кавычках является точным соответствием её двойника без кавычек (например, строка 'abc' строго равна abc).

Языки, которые не требуют, чтобы строки были в кавычках, определенно, в меньшинстве, так что **строки должны всегда быть обёрнуты в одинарные кавычки** в Sass (одну проще набрать, чем двойную, на QWERTY-клавиатуре). Кроме того, для согласованности с другими языками, в том числе с двоюродным братом CSS – JavaScript’ом, есть несколько причин для такого выбора:
* названия цветов рассматриваются как цвета, когда без кавычек, что может привести к серьёзным проблемам;
* большинство синтаксических анализаторов будут в шоке от строк без кавычек;
* это помогает общей читаемости;
* нет обоснованной причины не оборачивать строки в кавычки.


    // Хорошо
    $direction: 'left';
    
    // Плохо
    $direction: left;
### Строки как значения CSS
Специальные значения CSS (идентификаторы), такие как `initial` или `sans-serif` требует не быть закавыченными. В самом деле, объявление `font-family: 'sans-serif'` потерпит неудачу, потому что CSS ожидает идентификатор, а не строку с кавычками. Именно поэтому, мы не оборачиваем в кавычки эти значения.

    // Хорошо
    $font-type: sans-serif;
    
    // Плохо
    $font-type: 'sans-serif';
Следовательно, можно провести различие между строками, которые должны использоваться как значения CSS (идентификаторы CSS), как в предыдущем примере, и строками, которые привязаны к типу данных Sass, например, к ключам мапы.

Первое без кавычек, а второе в одинарных кавычках.

### Строки, содержащие кавычки
Если строка содержит одну или несколько одинарных кавычек, можно воспользоваться оборачиванием строки в двойный кавычки ("), чтобы избежать применение эскейп-последовательностей в строке.
    // Хорошо
    @warn 'You can\'t do that.';
    
    // Хорошо
    @warn "You can't do that.";
### УРЛы
URL тоже должны быть в кавычках, по тем же причинам, что и выше:

    // Хорошо
    .foo {
      background-image: url('/images/kittens.jpg');
    }
    
    // Плохо
    .foo {
      background-image: url(/images/kittens.jpg);
    }
### Числа
В Sass число – это тип данных, включая всё, от безразмерных чисел до длин, длительности, частоты, углов и так далее. Это позволяет проводить на них расчёты.

### Нули
В десятичных положительных значениях чисел меньше единицы следует ставить нуль перед точкой. Никогда не ставить незначащие нули после точки.

    // Хорошо
    .foo {
        padding: 2rem;
        opacity: 0.5;
    }
    
    // Плохо
    .foo {
        padding: 2.0rem;
        opacity: .5;
    }
### Едицины измерения
При работе с длинами, 0 (нуль) никогда не должен иметь единицу измерения.

    // Хорошо
    $length: 0;
    
    // Плохо
    $length: 0rem;
    
> **Замечание** — Внимательно, эта практика относится только к длинам. Нуль без единиц измерения для свойств времени, таких как `transition-delay` не допускается. Теоретически, если нуль без единиц измерения указан для продолжительности, это объявление признаётся недействительным и отбрасывается. Не все браузеры столько строги, но некоторые да. Короче говоря: опускать единицу измерения только для длин.

### Вычисления
**Числовые рассчёты должны всегда быть в круглых скобках.** Мало того, что это требование значительно улучшает читаемость, оно также предотвращает некоторые крайние случаи, заставляя Sass считать содержимое скобок.

    // Хорошо
    .foo {
      width: (100% / 3);
    }
    
    // Плохо
    .foo {
      width: 100% / 3;
    }
### Цвета
Цвета занимают важное место в языке CSS. Естественно, Sass является ценным союзником, когда дело доходит до управления цветами, в основном – путём предоставления [мощных функций.](https://sass-lang.com/documentation/modules)

Цветовые форматы
Для того, чтобы сделать цвета простыми, насколько возможно, советую соблюдать следующий порядок предпочтения цветовых форматов:

[Обозначение HSL;](https://en.wikipedia.org/wiki/HSL_and_HSV)
[Обозначение RGB;](https://en.wikipedia.org/wiki/RGB_color_model)
Шестнадцатеричная нотация. Предпочтительно в нижнем регистре и по возможности укороченная.
Представление HSL – не только самое простое для человеческого мозга, но у него и самый лёгкий способ настройки цвета путём регулировки цветового тона, насыщенности и яркости индивидуально.

RGB по-прежнему имеет преимущество, показывая прямо сейчас, что цвет более синий, зелёный или красный. Таким образом, этот способ может в некоторых случаях быть удачным, особенно при описании чистых красных, зеленых и синих цветов. Но это не делает его лёгким в построении цвета из трёх частей.

Наконец, шестнадцатеричное представление слишком сложно для расшифровки человеческим умом. Используйте его только в случае крайней необходимости.

    // Хорошо
    .foo {
      color: hsl(0, 100%, 50%);
    }
    
    // Тоже хорошо
    .foo {
      color: rgb(255, 0, 0);
    }
    
    // Приемлимо
    .foo {
      color: #f00;
    }
    
    // Тоже приемлимо
    .foo {
      color: #FF0000;
    }
    
    // Плохо
    .foo {
      color: red;
    }
При использовании обозначений HSL или RGB, всегда пишите один пробел после запятой (`,`) и не ставьте пробел между скобками ((`, `)) и содержимым.

    // Хорошо
    .foo {
      color: rgba(0, 0, 0, 0.1);
      background: hsl(300, 100%, 100%);
    }
    
    // Плохо
    .foo {
      color: rgba(0,0,0,.1);
      background: hsl( 300, 100%, 100% );
    }
### Цвета и переменные
При использовании цвета более одного раза, сохраняйте его в переменной с осмысленным названием, описывающим цвет.

    // Хорошо
    $light-green: rgb(90, 255, 170);
    
     // Плохо
    $header-phone-icon: #fff000;
Теперь вы можете использовать эту переменную, когда захотите. Однако, если ваше использование сильно привязано к теме, я бы не советовал использовать переменные как есть. Вместо этого, храните их в других переменных с именем, объясняющим, как она должна быть использована.

    $header-phone-icon: $light-green;
# Набор правил CSS
На данный момент, это, в основном, пересмотр того, что все и так знают, но вот как набор правил CSS должен быть написан (по крайней мере, по мнению большинства руководств, в том числе [CSS Guidelines):](https://cssguidelin.es/#anatomy-of-a-ruleset)

* связанные селекторы на одной строке; не связанные селекторы на новой строке;
* открывающая скобка (`{`) отделяется от последнего селектора одним пробелом;
* каждое объявление на собственной новой строке;
* пробел после двоеточия (`:`);
* завершающая точка с запятой (`;`) в конце всех объявлений;
* закрывающая скобка (`}`) на своей новой строке;
* новая строка после закрывающей скобки `}`.


    // Хорошо
    .foo, .foo-bar,
    .baz {
      display: block;
      overflow: hidden;
      margin: 0 auto;
    }
    
    // Плохо
    .foo,
    .foo-bar, .baz {
        display: block;
        overflow: hidden;
        margin: 0 auto }
Дополняя те руководства по CSS, мы должны обратить внимание на:
* локальные переменные объявляются перед любыми объявлениями, потом отделяются от деклараций новой строкой;
* вызовы примесей без `@@content` идут перед любым объявлением;
* вложенные селекторы всегда идут после новой строки;
* вызовы примесей с `@@content` идут после вложенных селекторов;
* без новых строк перед закрывающей фигурной скобкой (`}`).


    .foo, .foo-bar,
    .baz {
      $length: 10rem;
    
      @include ellipsis;
      @include size($length);
      display: block;
      overflow: hidden;
      margin: 0 auto;
    
      &:hover {
        color: red;
      }
    
      @include media-breakpoint-up(lg) {
        overflow: visible;
      }
    }
# Порядок объявлений
Невозможно удержать в голове все обсуждения, где мнения о сортировке объявлений в CSS настолько разнятся. Вообще, можно выявить два лагеря:

* придерживаться алфавитного порядка;
* упорядочивание по назначению (position, display, colors, font, miscellaneous…).

Есть плюсы и минусы в обоих вариантах. С одной стороны, сортировка в алфавитном порядке является универсальной (по крайней мере, для языков, использующих латинский алфавит), поэтому нет никаких споров о сортировке свойств. Тем не менее, мне весьма странно видеть свойства, такие как bottom и top, не рядом друг с другом. Почему анимации должны быть перед display? Есть много странностей с алфавитным упорядочиванием.

    .foo {
      background: black;
      bottom: 0;
      color: white;
      font-weight: bold;
      font-size: 1.5em;
      height: 100px;
      overflow: hidden;
      position: absolute;
      right: 0;
      width: 100px;
    }
С другой стороны, сортировка свойств по типу имеет смысл. Каждые объявления, относящиеся к шрифтам, располагаются рядом, как `top` и `bottom`, и чтение набора правил отчасти становится похожим на чтение рассказа.

    .foo {
      overflow: hidden;
      position: absolute;
      bottom: 0;
      right: 0;
      display: flex;
      justify-content: center;
      height: 100px;
      width: 100px;
      background: black;
      color: white;
      font-weight: bold;
      font-size: 1.5em;
    }
[Согласно опросу на CSS-Tricks](https://css-tricks.com/poll-results-how-do-you-order-your-css-properties/) более 45% разработчиков упорядочивают свойства по их назначению, против 14% в алфавитном порядке. Кроме того, 39% об этом вообще не думают

Я предлагаю остановиться на варианте с группированием по типу, т.к. он несет в себе больше логики и читабельности кода

# Вложенность селекторов
### Общие правила
Например, такая вложенность Sass:

    .foo {
      .bar {
        &:hover {
          color: red;
        }
      }
    }
…создаст такой CSS:

    .foo .bar:hover {
      color: red;
    }
Начиная с Sass 3.3 можно использовать ссылку на текущий селектор, используя &, чтобы создать дополнительные селекторы. Например:

    .foo {
      &-bar {
        color: red;
      }
    }
сгенерирует такой CSS:

    .foo-bar {
      color: red;
    }
>**Замечание** — Выходит анекдотично, что создание новых селекторов из ссылки на текущий селектор (&) делает новые селекторы недоступными для поиска в кодовой базе, так как они не существуют как таковые.

Проблема с вложенностью селекторов в том, что это в конечном итоге делает код более трудным для чтения. Нужно уметь мысленно вычислять, что получится в результате из уровней вложенности; не всегда вполне очевидно, что за CSS будет в конечном итоге.

Это утверждение становится правдивее, когда селекторы становятся длиннее и ссылки на текущий селектор (&) более частыми. В какой-то момент риск потерять след и не суметь понять, что происходит, становится настолько высок, что не стоит того.

Рекомендую **избегать вложенности селекторов, насколько это возможно.**

### Исключения
Для начала, допускается, и я даже рекомендую, вкладывать псевдоклассы и псевдоэлементы в родительский селектор.

    .foo {
      color: $white;
    
      &:hover {
        color: $black;
      }
    
      &:before {
        content: 'pseudo-element';
      }
    }
Использование вложенности селекторов для псевдоклассов и псевдоэлементов не только имеет смысл (потому что имеет дело с тесно связанными селекторами), но также помогает держать всю информацию о компоненте в одном месте.

Кроме того, при использовании классов, обозначающих состояние, таких как .is-active, это прекрасно подходит для того, чтобы вкладывать их под селектор компонента, чтобы всё выглядело аккуратно.

    .foo {
      // …
    
      &.is-active {
        font-weight: bold;
      }
    }
Последнее, но не менее важное – при оформлении элемента часто случается, что он содержится в другом элементе, и тут также хорошо использовать вложенность, чтобы держать всё о компоненте в том же месте.

    .foo {
      // …
    
      .no-opacity & {
        display: none;
      }
    }
# Архитектура
Разработка архитектуры CSS-проекта, вероятно, одна из самых сложных задач, которую придётся сделать в жизни проекта. Сохранять архитектуру последовательной и значимой – ещё сложнее.

### Компоненты
Существует главное отличие между тем, чтобы сделать код работающим, или сделать его хорошим. Опять таки, CSS – довольно путаный язык [указать источник]. Чем меньше CSS, тем лучше. Мы не хотим иметь дело с мегабайтами кода. Чтобы держать файлы стилей короткими и эффективными – и это не будет для вас сюрпризом – чаще всего будет хорошей идеей подумать об интерфейсе, как о наборе компонентов.

Компоненты могут быть чем угодно, до тех пор, пока они:

* делают одну и только одну вещь;
* могут быть повторно используемы;
* независимы.\

Например, форма поиска должна рассматриваться в качестве компонента. Она должна иметь возможность быть используемой повторно на разных страницах, в различных ситуациях. Она не должна зависеть от положения в DOM (в подвале, в боковой панели, в основном содержимом…).

Большинство интерфейсов можно рассматривать как набор маленьких компонентов, и я настоятельно рекомендую вам придерживаться этой парадигмы. Это позволит не только сократить количество CSS, необходимого для всего проекта, но также упростить его поддержку, и прибрать хаотический беспорядок.

### Структура компонента
В идеале, компоненты должны располагаться в своих собственных файлах (partial) (в папке `components/`, например `components/_object-list.scss`. Стили, описываемые в каждом компоненте должны быть связаны только с:

* стилем самого компонента;
* стилем вариантом компонента, его модификаторами и состояниями;
* стили потомков компонента (то есть детей), если это необходимо.

В файл компонента можно включать специфичные для этого компонента переменные, плейсхолдеры и даже миксины и функции. Однако имейте в виду, что следует избегать зависимостей (то есть `@import`-а) от других компонентов, так как привратит проект в мешанину неконтролируемых зависимостей, которые невозможно поддерживать.

Шаблон 7-1
Возвратимся к архитектуре? Я обычно использую так называемый Шаблон 7-1: 7 папок, 1 файл. Обычно весь наш код можно распределить в 7 папок и один файл в корневом каталоге (обычно с именем `main.scss`), который импортирует их все.

* `abstract/`
* `base/`
* `components/`
* `layout/`
* `pages/`
* `themes/`
* `vendors/`

И, конечно же:

* `main.scss`

В конечном итоге структура проекта выглядит следующим образом:

    styles/
    │
    ├── abstracts/
    │   ├── _variables.scss    # Переменные
    │   ├── _functions.scss    # Функции
    │   ├── _mixins.scss       # Миксины
    │   ├── _helpers.scss      # Хелперы и плейсхолдеры
    │
    ├── base/
    │   ├── _base.scss         # Стили для часто используемых элементов
    │   ├── _reset.scss        # Сброс стилей по-умолчанию
    │   ├── _typography.scss   # Типографика
    │   └── ...                # Прочее
    │
    ├── components/
    │   ├── _authors.scss      # Автор
    │   ├── _breadcrumbs.scss  # Хлебные крошки
    │   ├── _object-list.scss  # Список объектов
    │   ├── _person-list.scss  # Список людей
    │   └── ...                # И т.д.
    │
    ├── layout/
    │   ├── _navigation.scss   # Навигация
    │   ├── _header.scss       # Шапка
    │   ├── _footer.scss       # Футер
    │   ├── _sidebar.scss      # Сайдбар
    │   ├── _forms.scss        # Формы
    │   └── ...                # И т.д.
    
    ├── pages/
    │   ├── _index.scss        # Специфичные стили страницы Index
    │   ├── _commodities.scss  # Специфичные стили страницы Commodities
    │   ├── _contact.scss      # Специфичные стили страницы Contact
    │   └── ...                # И т.д.
    │
    ├── themes/
    │   ├── _theme.scss        # Тема по умолчанию
    │   ├── _admin.scss        # Тема админа
    │   └── ...                # И т.д.
    │
    ├── vendors/
    │   ├── _bootstrap.scss    # Bootstrap
    │   └── ...                # И т.д.
    │
    └── main.scss              # Главный Sass файл
>**Замечание** — Файлы с тем же соглашением по именованию, что и выше, начинаются с нижнего подчеркивания.

### Папка Base
Папка `base/` содержит то, что мы можем назвать общим шаблоном проекта. Там вы можете найти файл сброса, некоторые типографские правила, и, вероятно, стили (я привык их называть `_base.scss`), определяющие некоторые стандартные стили для часто используемых элементов HTML.

* `._base.scss`
* `._reset.scss`
* `._typography.scss`

В файл `\_typography.scss` импортируем кастомный шрифт:

    @import '/content/fonts/avenir/avenir';
>**Замечание** — Если в проекте много CSS анимации, то, возможно, стоит добавить файл `\_animations.scss`, который будет содержать определения `@keyframes` всех анимаций. Если же в проекте всего пара таких штук, оставьте их рядом с селекторами, использующие их.

### Папка Layout
Папка `layout/` содержит всё, что принимает участие в постройке раскладки сайта или приложения. Эта папка может содержать стили для основных частей сайта (шапка, подвал, навигация, боковая панель…), сетка или даже CSS-стили для всех форм.

* `_header.scss`
* `_footer.scss`
* `_sidebar.scss`
* `_forms.scss`
* `_navigation.scss`
>**Замечание** — Папка `layout/` может быть названа `partials/`, на ваше усмотрение.

### Папка Components
Для маленьких компонентов существует папка `components/`. В то время, как `layout/` – основные (определяют общий каркас), код внутри `components/` больше сфокусирован на виджетах и содержит все модули, вроде слайдера, загрузчика и тому подобных виджетов. Обычно файлов в `components/` много, если приложение или сайт состоит из множества мелких модулей.

* `_authors.scss`
* `_breadcrumbs.scss`
* `_object-list.scss`
* `_person-list.scss`

### Папка Pages
Если есть стили, зависящие от страницы, лучше положить их в папку `pages/`, в файл, названный как и страница. Например, не редкость – иметь очень специфичные стили для главной страницы, следовательно, существует потребность в `_index.scss` в `pages/`.

* `_index.scss`
* `_commodities.scss`
* `_contact.scss`

### Папка Themes
В перспективе эта папка будет использоваться для определения различных тем

### Папка Abstracts
Папка `abstracts/` собирает все инструменты и хелперы Sass в проекте. Каждая глобальная переменная, функция и примесь должна быть помещена сюда.

Правило для этой папки в том, что она не должна создавать CSS при компиляции сама по себе. Это не что иное, как Sass хелперы.

* `_variables.scss`
* `_mixins.scss`
* `_functions.scss`
* `_helpers.scss`

### Папка Vendors
Нужно вложить или переиминовать scripts

Подключение внеших сторонних библиотек, которые должны храниться на сервере

* `/scripts/bootstrap/4.3.1/scss/_bootstrap.scss`

### Файл Main
Главный файл (обычно называемый `main.scss`) должен быть единственным файлом Sass, который не начинается с нижнего подчеркивания. Этот файл не должен содержать ничего, кроме `@import` и комментариев.

Файлы должны быть импортированы в соответствии с папками размещения, один за другим, в следующем порядке:

1. `abstracts/`
2. `vendors/`
3. `base/`
4. `layout/`
5. `components/`
6. `pages/`
7. `themes/`

Чтобы улучшить читаемость, главный файл должен следовать этим рекомендациям:

* один файл на один `@import`;
* один `@import` на строку;
* не вставлять пустую строку между файлами из одной папки;
* вставлять пустую строку после последнего импорта из папки;
* не писать расширения файлов и нижние подчеркивания.


    @import 'abstract/variables';
    @import "/scripts/bootstrap/4.3.1/scss/bootstrap";
    @import 'abstract/mixins';
    @import 'abstract/helpers';
    
    @import 'base/base';
    @import 'base/reset';
    @import 'base/typography';
    
    @import 'layout/main';
    @import 'layout/header';
    @import 'layout/navigation';
    @import 'layout/sidebar';
    @import 'layout/footer';
    
    @import 'components/authors';
    @import 'components/breadcrumbs';
    @import 'components/rating';
    @import 'components/object-list';
    @import 'components/company-list';
    @import 'components/person-list';
    @import 'components/review-list';
    @import 'components/commodity-list';
    
    @import 'pages/index';
    @import 'pages/clinics';
    @import 'pages/persons';
    @import 'pages/commodities';
    @import 'pages/generator';
    
    @import 'themes/theme';
    @import 'themes/admin';
>**Замечание** — т.к. наша платформа базируется на Bootstrap, для переопределения переменных подключаем их перед самой библиотекой, а затем подключаем сам Bootstrap, для того что бы можно было использовать его функции и миксины в наших `mixins` и `helpers`

# Типографика
В нашем проекте зашита концепция вертикального ритма и все размеры отталкиваются от базовой линии. Принцип следующий: для псевдоэлемента `:root` задается базовая линия, которая в свою очередь расчитывается в миксине `base-line` и `base-line_m` и она всегда равна `1rem` в пересчете. Это значение используется как стартовая точка, для указания всех размеров.

    @mixin base-line {
      @if $font-size-global == 14 {
        font-size: round($font-size-global / 0.6087);
      } @else if $font-size-global == 16 {
        font-size: round($font-size-global / 0.61538);
      } @else if $font-size-global == 18 {
        font-size: round($font-size-global / 0.62069);
      } @else if $font-size-global == 20 {
        font-size: round($font-size-global / 0.625);
      } @else {
        font-size: round($font-size-global / 0.618);
      }
    }
    
    @mixin base-line_m {
      @if $font-size-global_m == 14 {
        font-size: round($font-size-global_m / 0.6087);
      } @else if $font-size-global_m == 16 {
        font-size: round($font-size-global_m / 0.61538);
      } @else if $font-size-global_m == 18 {
        font-size: round($font-size-global_m / 0.62069);
      } @else if $font-size-global_m == 20 {
        font-size: round($font-size-global_m / 0.625);
      } @else {
        font-size: round($font-size-global_m / 0.618);
      }
    }
Чтобы задать базовую линии нужно всего лишь указать размер желаемого шрифта для десктопа и мобильных устройств в переменных `$font-size-global` и `$font-size-global_m`

Пример файла `_typography.scss`

@import '/content/fonts/avenir/avenir';

    :root {
      @include base-line_m();
      @include media-breakpoint-up(md) {
        @include base-line();
      }
    }
    
    body {
      font-size: $font-size-global_m;
      line-height: 1rem;
      @include media-breakpoint-up(md) {
        font-size: $font-size-global;
      }
    }
    
    h1, .h1 {
      margin-bottom: 1.5rem;
      line-height: 2rem;
    }
    
    h2, .h2 {
      font-size: 1.25rem;
      margin-bottom: 1rem;
      line-height: 1.5rem;
    }
    
    h3, .h3 {
      font-size: 1.125rem;
      margin-bottom: .75rem;
      line-height: 1rem;
    }
    
    h4, .h4 {
      font-size: 1rem;
      margin-bottom: .5rem;
      line-height: 1rem;
    }
    
    h5, .h5 {
      font-size: 0.85rem;
      margin-bottom: .5rem;
      line-height: 1rem;
    }
    
    h6, .h6 {
      font-size: 0.7rem;
      margin-bottom: .5rem;
      line-height: 1rem;
    }
# Переменные
Исходя из полученного опыта, могу сказать что излишнее использование переменных отрицательно сказывается на читабельности и переопределении перменных. Со смелостью можно сказать, что пока **в 99% случаях** из переопределения переменных из проекта в проекте остаются лишь цвета, шрифты и некоторые размеры. В остальном все типично и все зависит от конкретного случая и задачи.

В процессе развития мы придем к эталонным компонентам, которые можно будешь использовать как железобетонный фундамент и скрестим это с темами

>**Замечание** — Настоятельно рекомендую потратить время и изучить [переменные Bootstrap](https://github.com/twbs/bootstrap/blob/main/scss/_variables.scss) для активного их применения

Bootstrap заложил в переменные очень многие вещи, от рассчётов цветов функциями до отступов `label`. Нам нужно стараться использовать единий подход к написанию стилей, придерживаться стайлгайда, описанного выше и использовать перменные Bootstrap.

Из общих рекомендаций скажу, что нужно стремиться к тому, что бы все цвета использовались из переменных, либо [функций sass](https://sass-lang.com/documentation/modules/color), которые могут видоизменять их.

    $gray-100: #f8f9fa;
    $gray-200: #e9ecef;
    $gray-300: #dee2e6;
    $gray-400: #ced4da;
    $gray-500: #adb5bd;
    $gray-600: #6c757d;
    $gray-700: #495057;
    $gray-800: #343a40;
    $gray-900: #212529;
    $white:    #ffffff;
    $black:    #000000;
    $red:      #e23f41;
    $green:    #029c54;
    
    $primary:       #00afcc;
    $secondary:     #f26d64;
    $accent:        #3A3A3A;
    $foreground:    #f5f5f5;
    $background:    #fcfcfc;
Также часто используемыми переменными по ходу написания стилей являются:

    // Скругление углов
    $border-radius:               .25rem;
    $border-radius-lg:            .3rem;
    $border-radius-sm:            .2rem;
    
    // Тени
    $box-shadow-sm:               0 .125rem .25rem rgba($black, .075);
    $box-shadow:                  0 .5rem 1rem rgba($black, .15);
    $box-shadow-lg:               0 1rem 3rem rgba($black, .175);
    
    // Переходы
    $transition-base:             all .2s ease-in-out;
    $transition-fade:             opacity .15s linear;
    $transition-collapse:         height .35s ease;
    
    // Размер шрифта для мелкого текста
    $small-font-size:             80%;
    
    // И т.д. см.переменные Bootstrap
# Размеры
Для того что бы поддерживать вертикальным ритм, для всех размеров нужно использовать единицы измерения rem. Будь то отступ или ширина элемента.

Настоятельно рекомендуется использовать **величины кратные 0.25**, чтобы не нарушать ритм, в крайнем случае можно прибегнуть к кратности 0.125

    // Хорошо
    .foo {
        padding: 0.75rem 1.25rem;
        min-width: 5rem;
        font-size: 1.25rem;
        line-height: 1.5rem;
    }

    // Плохо
    .foo {
        padding: 0.44rem 1.15rem;
        min-width: 5.38rem;
        font-size: 1.09rem;
        line-height: 1.1rem;
    }
# Адаптивность
В наше время адаптивность играет ключевую роль, трафик с мобильных устройств уже перевалил за эквартор, в следствии чего, нужно придериваться подхода **mobile first**

Для написания стилей под разные устройства за основу взята карта брейкпойнтов Bootstrap.

    $grid-breakpoints: (
            xs: 0,
            sm: 576px,
            md: 768px,
            lg: 992px,
            xl: 1240px
    );
Если есть необходимость можно добавить свой брейкпойнт дописав его в конец карты:

    $grid-breakpoints: (
            xs: 0,
            sm: 576px,
            md: 768px,
            lg: 992px,
            xl: 1240px,
            fl: 1680px  // Брейкпоинт для больших экранов
    );
Соответсвенно при написании стилей активно используем встроенные миксины медиа запросов от Bootstrap, а именно `@include media-breakpoint-up` основанный на минимальной ширине, т.к. мы используем подход mobile first

    // Хорошо
    .foo {
        margin: 0.5rem;
        @include media-breakpoint-up(md) {
            margin: 1rem;
        }
        @include media-breakpoint-up(xl) {
            margin: 1.5rem;
        }
    }
    
    // Плохо
    .foo {
        margin: 0.5rem;
        @include media-breakpoint-down(md) {
            margin: 0.75rem
        }
        @media (min-width: 1320px) {
            margin: 1rem;
        }
    }
